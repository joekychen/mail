<!DOCTYPE html>
<html><head><title>joekychen/mail » lib › mail › multibyte › chars.rb
| encoding: utf-8
</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../../index.html"></a><h1>chars.rb</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div><p>encoding: utf-8</p></td><td class="code"><div class="highlight"><pre><span class="k">module</span> <span class="nn">Mail</span> <span class="c1">#:nodoc:</span>
  <span class="k">module</span> <span class="nn">Multibyte</span> <span class="c1">#:nodoc:</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>Chars enables you to work transparently with UTF-8 encoding in the Ruby String class without having extensive
knowledge about the encoding. A Chars object accepts a string upon initialization and proxies String methods in an
encoding safe manner. All the normal String methods are also implemented on the proxy.</p>

<p>String methods are proxied through the Chars object, and can be accessed through the +mb_chars+ method. Methods
which would normally return a String object now return a Chars object so methods can be chained.</p>

<p>"The Perfect String  ".mb_chars.downcase.strip.normalize # => "the perfect string"</p>

<p>Chars objects are perfectly interchangeable with String objects as long as no explicit class checks are made.
If certain methods do explicitly check the class, call +to_s+ before you pass chars objects to them.</p>

<p>bad.explicit<em>checking</em>method "T".mb<em>chars.downcase.to</em>s</p>

<p>The default Chars implementation assumes that the encoding of the string is UTF-8, if you want to handle different
encodings you can write your own multibyte string handler and configure it through
Mail::Multibyte.proxy_class.</p>

<p>class CharsForUTF32
    def size
      @wrapped_string.size / 4
    end</p>

<pre><code>def self.accepts?(string)
  string.length % 4 == 0
end
</code></pre>

<p>end</p>

<p>Mail::Multibyte.proxy_class = CharsForUTF32</p></td><td class="code"><div class="highlight"><pre>    <span class="k">class</span> <span class="nc">Chars</span>
      <span class="kp">attr_reader</span> <span class="ss">:wrapped_string</span>
      <span class="k">alias</span> <span class="nb">to_s</span> <span class="n">wrapped_string</span>
      <span class="k">alias</span> <span class="n">to_str</span> <span class="n">wrapped_string</span>

      <span class="k">if</span> <span class="no">RUBY_VERSION</span> <span class="o">&gt;=</span> <span class="s2">&quot;1.9&quot;</span></pre></div></td></tr>


<tr id="section-3"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-3">&#182;</a></div><p>Creates a new Chars instance by wrapping <em>string</em>.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
          <span class="vi">@wrapped_string</span> <span class="o">=</span> <span class="n">string</span>
          <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">force_encoding</span><span class="p">(</span><span class="no">Encoding</span><span class="o">::</span><span class="no">UTF_8</span><span class="p">)</span> <span class="k">unless</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">frozen?</span>
        <span class="k">end</span>
      <span class="k">else</span>
        <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
          <span class="vi">@wrapped_string</span> <span class="o">=</span> <span class="n">string</span>
        <span class="k">end</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-4"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-4">&#182;</a></div><p>Forward all undefined methods to the wrapped string.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">method_missing</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">method</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=~</span> <span class="sr">/!$/</span>
          <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
          <span class="nb">self</span>
        <span class="k">else</span>
          <span class="n">result</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">__send__</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
          <span class="n">result</span><span class="o">.</span><span class="n">kind_of?</span><span class="p">(</span><span class="nb">String</span><span class="p">)</span> <span class="p">?</span> <span class="n">chars</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="p">:</span> <span class="n">result</span>
        <span class="k">end</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-5"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-5">&#182;</a></div><p>Returns +true+ if <em>obj</em> responds to the given method. Private methods are included in the search
only if the optional second parameter evaluates to +true+.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">include_private</span><span class="o">=</span><span class="kp">false</span><span class="p">)</span>
        <span class="k">super</span> <span class="o">||</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="nb">method</span><span class="p">,</span> <span class="n">include_private</span><span class="p">)</span> <span class="o">||</span> <span class="kp">false</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-6"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-6">&#182;</a></div><p>Enable more predictable duck-typing on String-like classes. See Object#acts_like?.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">acts_like_string?</span>
        <span class="kp">true</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-7"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-7">&#182;</a></div><p>Returns +true+ when the proxy class can handle the string. Returns +false+ otherwise.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">consumes?</span><span class="p">(</span><span class="n">string</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-8"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-8">&#182;</a></div><p>Unpack is a little bit faster than regular expressions.</p></td><td class="code"><div class="highlight"><pre>        <span class="n">string</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
        <span class="kp">true</span>
      <span class="k">rescue</span> <span class="no">ArgumentError</span>
        <span class="kp">false</span>
      <span class="k">end</span>

      <span class="kp">include</span> <span class="no">Comparable</span></pre></div></td></tr>


<tr id="section-9"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-9">&#182;</a></div><p>Returns -1, 0, or 1, depending on whether the Chars object is to be sorted before,
equal or after the object on the right side of the operation. It accepts any object
that implements +to_s+:</p>

<p>'é'.mb<em>chars &lt;=> 'ü'.mb</em>chars # => -1</p>

<p>See <tt>String#&lt;=></tt> for more details.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">&lt;=&gt;</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="vi">@wrapped_string</span> <span class="o">&lt;=&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">to_s</span>
      <span class="k">end</span>

      <span class="k">if</span> <span class="no">RUBY_VERSION</span> <span class="o">&lt;</span> <span class="s2">&quot;1.9&quot;</span></pre></div></td></tr>


<tr id="section-10"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-10">&#182;</a></div><p>Returns +true+ if the Chars class can and should act as a proxy for the string <em>string</em>. Returns
+false+ otherwise.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">wants?</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
          <span class="vg">$KCODE</span> <span class="o">==</span> <span class="s1">&#39;UTF8&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">consumes?</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-11"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-11">&#182;</a></div><p>Returns a new Chars object containing the <em>other</em> object concatenated to the string.</p>

<p>Example:
  ('Café'.mb<em>chars + ' périferôl').to</em>s # => "Café périferôl"</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">+</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
          <span class="n">chars</span><span class="p">(</span><span class="vi">@wrapped_string</span> <span class="o">+</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-12"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-12">&#182;</a></div><p>Like <tt>String#=~</tt> only it returns the character offset (in codepoints) instead of the byte offset.</p>

<p>Example:
  'Café périferôl'.mb_chars =~ /ô/ # => 12</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="o">=~</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
          <span class="n">translate_offset</span><span class="p">(</span><span class="vi">@wrapped_string</span> <span class="o">=~</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-13"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-13">&#182;</a></div><p>Inserts the passed string at specified codepoint offsets.</p>

<p>Example:
  'Café'.mb<em>chars.insert(4, ' périferôl').to</em>s # => "Café périferôl"</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span>
          <span class="n">unpacked</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span>
          <span class="k">unless</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">length</span>
            <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
              <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="o">*</span><span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="n">fragment</span><span class="p">))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
            <span class="p">)</span>
          <span class="k">else</span>
            <span class="k">raise</span> <span class="no">IndexError</span><span class="p">,</span> <span class="s2">&quot;index </span><span class="si">#{</span><span class="n">offset</span><span class="si">}</span><span class="s2"> out of string&quot;</span>
          <span class="k">end</span>
          <span class="nb">self</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-14"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-14">&#182;</a></div><p>Returns +true+ if contained string contains <em>other</em>. Returns +false+ otherwise.</p>

<p>Example:
  'Café'.mb_chars.include?('é') # => true</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">include?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></pre></div></td></tr>


<tr id="section-15"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-15">&#182;</a></div><p>We have to redefine this method because Enumerable defines it.</p></td><td class="code"><div class="highlight"><pre>          <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-16"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-16">&#182;</a></div><p>Returns the position <em>needle</em> in the string, counting in codepoints. Returns +nil+ if <em>needle</em> isn't found.</p>

<p>Example:
  'Café périferôl'.mb<em>chars.index('ô')   # => 12
  'Café périferôl'.mb</em>chars.index(/\w/u) # => 0</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
          <span class="n">wrapped_offset</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped_string</span><span class="o">.</span><span class="n">length</span>
          <span class="n">index</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">wrapped_offset</span><span class="p">)</span>
          <span class="n">index</span> <span class="p">?</span> <span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">index</span><span class="p">))</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="p">:</span> <span class="kp">nil</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-17"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-17">&#182;</a></div><p>Returns the position <em>needle</em> in the string, counting in
codepoints, searching backward from <em>offset</em> or the end of the
string. Returns +nil+ if <em>needle</em> isn't found.</p>

<p>Example:
  'Café périferôl'.mb<em>chars.rindex('é')   # => 6
  'Café périferôl'.mb</em>chars.rindex(/\w/u) # => 13</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">rindex</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kp">nil</span><span class="p">)</span>
          <span class="n">offset</span> <span class="o">||=</span> <span class="n">length</span>
          <span class="n">wrapped_offset</span> <span class="o">=</span> <span class="n">first</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">wrapped_string</span><span class="o">.</span><span class="n">length</span>
          <span class="n">index</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">rindex</span><span class="p">(</span><span class="n">needle</span><span class="p">,</span> <span class="n">wrapped_offset</span><span class="p">)</span>
          <span class="n">index</span> <span class="p">?</span> <span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">index</span><span class="p">))</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="p">:</span> <span class="kp">nil</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-18"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-18">&#182;</a></div><p>Returns the number of codepoints in the string</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">size</span>
          <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">size</span>
        <span class="k">end</span>
        <span class="n">alias_method</span> <span class="ss">:length</span><span class="p">,</span> <span class="ss">:size</span></pre></div></td></tr>


<tr id="section-19"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-19">&#182;</a></div><p>Strips entire range of Unicode whitespace from the right of the string.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">rstrip</span>
          <span class="n">chars</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="no">Unicode</span><span class="o">::</span><span class="no">TRAILERS_PAT</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-20"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-20">&#182;</a></div><p>Strips entire range of Unicode whitespace from the left of the string.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">lstrip</span>
          <span class="n">chars</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="no">Unicode</span><span class="o">::</span><span class="no">LEADERS_PAT</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-21"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-21">&#182;</a></div><p>Strips entire range of Unicode whitespace from the right and left of the string.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">strip</span>
          <span class="n">rstrip</span><span class="o">.</span><span class="n">lstrip</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-22"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-22">&#182;</a></div><p>Returns the codepoint of the first character in the string.</p>

<p>Example:
  'こんにちは'.mb_chars.ord # => 12371</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">ord</span>
          <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-23"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-23">&#182;</a></div><p>Works just like <tt>String#rjust</tt>, only integer specifies characters instead of bytes.</p>

<p>Example:</p>

<p>"¾ cup".mb<em>chars.rjust(8).to</em>s
  # => "   ¾ cup"</p>

<p>"¾ cup".mb<em>chars.rjust(8, " ").to</em>s # Use non-breaking whitespace
  # => "   ¾ cup"</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">rjust</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">padstr</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
          <span class="n">justify</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="ss">:right</span><span class="p">,</span> <span class="n">padstr</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-24"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-24">&#182;</a></div><p>Works just like <tt>String#ljust</tt>, only integer specifies characters instead of bytes.</p>

<p>Example:</p>

<p>"¾ cup".mb<em>chars.rjust(8).to</em>s
  # => "¾ cup   "</p>

<p>"¾ cup".mb<em>chars.rjust(8, " ").to</em>s # Use non-breaking whitespace
  # => "¾ cup   "</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">ljust</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">padstr</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
          <span class="n">justify</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="ss">:left</span><span class="p">,</span> <span class="n">padstr</span><span class="p">)</span>
        <span class="k">end</span></pre></div></td></tr>


<tr id="section-25"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-25">&#182;</a></div><p>Works just like <tt>String#center</tt>, only integer specifies characters instead of bytes.</p>

<p>Example:</p>

<p>"¾ cup".mb<em>chars.center(8).to</em>s
  # => " ¾ cup  "</p>

<p>"¾ cup".mb<em>chars.center(8, " ").to</em>s # Use non-breaking whitespace
  # => " ¾ cup  "</p></td><td class="code"><div class="highlight"><pre>        <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">padstr</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
          <span class="n">justify</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="ss">:center</span><span class="p">,</span> <span class="n">padstr</span><span class="p">)</span>
        <span class="k">end</span>

      <span class="k">else</span>
        <span class="k">def</span> <span class="o">=~</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
          <span class="vi">@wrapped_string</span> <span class="o">=~</span> <span class="n">other</span>
        <span class="k">end</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-26"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-26">&#182;</a></div><p>Works just like <tt>String#split</tt>, with the exception that the items in the resulting list are Chars
instances instead of String. This makes chaining methods easier.</p>

<p>Example:
  'Café périferôl'.mb<em>chars.split(/é/).map { |part| part.upcase.to</em>s } # => ["CAF", " P", "RIFERÔL"]</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span><span class="o">.</span><span class="n">mb_chars</span> <span class="p">}</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-27"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-27">&#182;</a></div><p>Like <tt>String#[]=</tt>, except instead of byte offsets you specify character offsets.</p>

<p>Example:</p>

<p>s = "Müller"
  s.mb_chars[2] = "e" # Replace character with offset 2
  s
  # => "Müeler"</p>

<p>s = "Müller"
  s.mb_chars[1, 2] = "ö" # Replace 2 characters at character offset 1
  s
  # => "Möler"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">[]=</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="n">replace_by</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span></pre></div></td></tr>


<tr id="section-28"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-28">&#182;</a></div><p>Indexed replace with regular expressions already works</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Regexp</span><span class="p">)</span>
          <span class="vi">@wrapped_string</span><span class="o">[*</span><span class="n">args</span><span class="o">]</span> <span class="o">=</span> <span class="n">replace_by</span>
        <span class="k">else</span>
          <span class="n">result</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Fixnum</span><span class="p">)</span>
            <span class="k">raise</span> <span class="no">IndexError</span><span class="p">,</span> <span class="s2">&quot;index </span><span class="si">#{</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="s2"> out of string&quot;</span> <span class="k">if</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="n">result</span><span class="o">.</span><span class="n">length</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="n">nil?</span> <span class="p">?</span> <span class="n">min</span> <span class="p">:</span> <span class="p">(</span><span class="n">min</span> <span class="o">+</span> <span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">range</span> <span class="o">=</span> <span class="no">Range</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">replace_by</span> <span class="o">=</span> <span class="o">[</span><span class="n">replace_by</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">replace_by</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Fixnum</span><span class="p">)</span>
          <span class="k">elsif</span> <span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Range</span><span class="p">)</span>
            <span class="k">raise</span> <span class="no">RangeError</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">#{</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="si">}</span><span class="s2"> out of range&quot;</span> <span class="k">if</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">min</span> <span class="o">&gt;=</span> <span class="n">result</span><span class="o">.</span><span class="n">length</span>
            <span class="n">range</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
          <span class="k">else</span>
            <span class="n">needle</span> <span class="o">=</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_s</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="n">needle</span><span class="p">)</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">range</span> <span class="o">=</span> <span class="no">Range</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">)</span>
          <span class="k">end</span>
          <span class="n">result</span><span class="o">[</span><span class="n">range</span><span class="o">]</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="n">replace_by</span><span class="p">)</span>
          <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">))</span>
        <span class="k">end</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-29"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-29">&#182;</a></div><p>Reverses all characters in the string.</p>

<p>Example:
  'Café'.mb<em>chars.reverse.to</em>s # => 'éfaC'</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">reverse</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">g_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">flatten</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">))</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-30"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-30">&#182;</a></div><p>Implements Unicode-aware slice with codepoints. Slicing on one point returns the codepoints for that
character.</p>

<p>Example:
  'こんにちは'.mb<em>chars.slice(2..3).to</em>s # => "にち"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">2</span>
          <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;wrong number of arguments (</span><span class="si">#{</span><span class="n">args</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> for 1)&quot;</span> <span class="c1"># Do as if we were native</span>
        <span class="k">elsif</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Numeric</span><span class="p">)</span> <span class="o">||</span> <span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Regexp</span><span class="p">)))</span>
          <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">&quot;cannot convert </span><span class="si">#{</span><span class="n">args</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">class</span><span class="si">}</span><span class="s2"> into Integer&quot;</span> <span class="c1"># Do as if we were native</span>
        <span class="k">elsif</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Numeric</span><span class="p">))</span>
          <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">&quot;cannot convert </span><span class="si">#{</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">].</span><span class="n">class</span><span class="si">}</span><span class="s2"> into Integer&quot;</span> <span class="c1"># Do as if we were native</span>
        <span class="k">elsif</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">kind_of?</span> <span class="no">Range</span>
          <span class="n">cps</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">cps</span><span class="o">.</span><span class="n">nil?</span> <span class="p">?</span> <span class="kp">nil</span> <span class="p">:</span> <span class="n">cps</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
        <span class="k">elsif</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">kind_of?</span> <span class="no">Regexp</span>
          <span class="n">result</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">elsif</span> <span class="n">args</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">kind_of?</span><span class="p">(</span><span class="no">Numeric</span><span class="p">)</span>
          <span class="n">character</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">[</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">character</span> <span class="o">&amp;&amp;</span> <span class="o">[</span><span class="n">character</span><span class="o">].</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U&#39;</span><span class="p">)</span>
        <span class="k">else</span>
          <span class="n">cps</span> <span class="o">=</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
          <span class="n">result</span> <span class="o">=</span> <span class="n">cps</span> <span class="o">&amp;&amp;</span> <span class="n">cps</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span>
        <span class="k">end</span>
        <span class="n">result</span> <span class="o">&amp;&amp;</span> <span class="n">chars</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">alias_method</span> <span class="ss">:[]</span><span class="p">,</span> <span class="ss">:slice</span></pre></div></td></tr>


<tr id="section-31"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-31">&#182;</a></div><p>Limit the byte size of the string to a number of bytes without breaking characters. Usable
when the storage for a string is limited for some reason.</p>

<p>Example:
  s = 'こんにちは'
  s.mb_chars.limit(7) # => "こに"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="n">limit</span><span class="p">)</span>
        <span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">translate_offset</span><span class="p">(</span><span class="n">limit</span><span class="p">))</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-32"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-32">&#182;</a></div><p>Convert characters in the string to uppercase.</p>

<p>Example:
  'Laurent, où sont les tests ?'.mb<em>chars.upcase.to</em>s # => "LAURENT, OÙ SONT LES TESTS ?"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">upcase</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">apply_mapping</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">),</span> <span class="ss">:uppercase_mapping</span><span class="p">)</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-33"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-33">&#182;</a></div><p>Convert characters in the string to lowercase.</p>

<p>Example:
  'VĚDA A VÝZKUM'.mb<em>chars.downcase.to</em>s # => "věda a výzkum"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">downcase</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">apply_mapping</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">),</span> <span class="ss">:lowercase_mapping</span><span class="p">)</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-34"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-34">&#182;</a></div><p>Converts the first character to uppercase and the remainder to lowercase.</p>

<p>Example:
 'über'.mb<em>chars.capitalize.to</em>s # => "Über"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">capitalize</span>
        <span class="p">(</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">chars</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">upcase</span> <span class="o">+</span> <span class="p">(</span><span class="n">slice</span><span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="n">chars</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">downcase</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-35"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-35">&#182;</a></div><p>Capitalizes the first letter of every word, when possible.</p>

<p>Example:
  "ÉL QUE SE ENTERÓ".mb<em>chars.titleize    # => "Él Que Se Enteró"
  "日本語".mb</em>chars.titleize                 # => "日本語"</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">titleize</span>
        <span class="n">chars</span><span class="p">(</span><span class="n">downcase</span><span class="o">.</span><span class="n">to_s</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/\b(&#39;?[\S])/u</span><span class="p">)</span> <span class="p">{</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">apply_mapping</span> <span class="vg">$1</span><span class="p">,</span> <span class="ss">:uppercase_mapping</span> <span class="p">})</span>
      <span class="k">end</span>
      <span class="n">alias_method</span> <span class="ss">:titlecase</span><span class="p">,</span> <span class="ss">:titleize</span></pre></div></td></tr>


<tr id="section-36"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-36">&#182;</a></div><p>Returns the KC normalization of the string by default. NFKC is considered the best normalization form for
passing strings to databases and validations.</p>

<ul>
<li><tt>form</tt> - The form you want to normalize in. Should be one of the following:
<tt>:c</tt>, <tt>:kc</tt>, <tt>:d</tt>, or <tt>:kd</tt>. Default is
Mail::Multibyte::Unicode.default<em>normalization</em>form</li>
</ul></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">form</span> <span class="o">=</span> <span class="kp">nil</span><span class="p">)</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">,</span> <span class="n">form</span><span class="p">))</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-37"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-37">&#182;</a></div><p>Performs canonical decomposition on all the characters.</p>

<p>Example:
  'é'.length                         # => 2
  'é'.mb<em>chars.decompose.to</em>s.length # => 3</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">decompose</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">decompose_codepoints</span><span class="p">(</span><span class="ss">:canonical</span><span class="p">,</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">))</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-38"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-38">&#182;</a></div><p>Performs composition on all the characters.</p>

<p>Example:
  'é'.length                       # => 3
  'é'.mb<em>chars.compose.to</em>s.length # => 2</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">compose</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">compose_codepoints</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">))</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">))</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-39"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-39">&#182;</a></div><p>Returns the number of grapheme clusters in the string.</p>

<p>Example:
  'क्षि'.mb<em>chars.length   # => 4
  'क्षि'.mb</em>chars.g_length # => 3</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">g_length</span>
        <span class="no">Unicode</span><span class="o">.</span><span class="n">g_unpack</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>
      <span class="k">end</span></pre></div></td></tr>


<tr id="section-40"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-40">&#182;</a></div><p>Replaces all ISO-8859-1 or CP1252 characters by their UTF-8 equivalent resulting in a valid UTF-8 string.</p>

<p>Passing +true+ will forcibly tidy all bytes, assuming that the string's encoding is entirely CP1252 or ISO-8859-1.</p></td><td class="code"><div class="highlight"><pre>      <span class="k">def</span> <span class="nf">tidy_bytes</span><span class="p">(</span><span class="n">force</span> <span class="o">=</span> <span class="kp">false</span><span class="p">)</span>
        <span class="n">chars</span><span class="p">(</span><span class="no">Unicode</span><span class="o">.</span><span class="n">tidy_bytes</span><span class="p">(</span><span class="vi">@wrapped_string</span><span class="p">,</span> <span class="n">force</span><span class="p">))</span>
      <span class="k">end</span>

       <span class="sx">%w(capitalize downcase lstrip reverse rstrip slice strip tidy_bytes upcase)</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="nb">method</span><span class="o">|</span></pre></div></td></tr>


<tr id="section-41"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-41">&#182;</a></div><p>Only define a corresponding bang method for methods defined in the proxy; On 1.9 the proxy will
exclude lstrip!, rstrip! and strip! because they are already work as expected on multibyte strings.</p></td><td class="code"><div class="highlight"><pre>        <span class="k">if</span> <span class="nb">public_method_defined?</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
          <span class="n">define_method</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span> <span class="k">do</span> <span class="o">|*</span><span class="n">args</span><span class="o">|</span>
            <span class="vi">@wrapped_string</span> <span class="o">=</span> <span class="nb">send</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">nil?</span> <span class="p">?</span> <span class="nb">method</span> <span class="p">:</span> <span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span>
            <span class="nb">self</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>

      <span class="kp">protected</span>

        <span class="k">def</span> <span class="nf">translate_offset</span><span class="p">(</span><span class="n">byte_offset</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
          <span class="k">return</span> <span class="kp">nil</span> <span class="k">if</span> <span class="n">byte_offset</span><span class="o">.</span><span class="n">nil?</span>
          <span class="k">return</span> <span class="mi">0</span>   <span class="k">if</span> <span class="vi">@wrapped_string</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>

          <span class="k">if</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:force_encoding</span><span class="p">)</span>
            <span class="vi">@wrapped_string</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">force_encoding</span><span class="p">(</span><span class="no">Encoding</span><span class="o">::</span><span class="no">ASCII_8BIT</span><span class="p">)</span>
          <span class="k">end</span>

          <span class="k">begin</span>
            <span class="vi">@wrapped_string</span><span class="o">[</span><span class="mi">0</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">byte_offset</span><span class="o">].</span><span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;U*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>
          <span class="k">rescue</span> <span class="no">ArgumentError</span>
            <span class="n">byte_offset</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">retry</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="k">def</span> <span class="nf">justify</span><span class="p">(</span><span class="n">integer</span><span class="p">,</span> <span class="n">way</span><span class="p">,</span> <span class="n">padstr</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
          <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;zero width padding&quot;</span> <span class="k">if</span> <span class="n">padstr</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">0</span>
          <span class="n">padsize</span> <span class="o">=</span> <span class="n">integer</span> <span class="o">-</span> <span class="n">size</span>
          <span class="n">padsize</span> <span class="o">=</span> <span class="n">padsize</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">padsize</span> <span class="p">:</span> <span class="mi">0</span>
          <span class="k">case</span> <span class="n">way</span>
          <span class="k">when</span> <span class="ss">:right</span>
            <span class="n">result</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding</span><span class="p">(</span><span class="n">padsize</span><span class="p">,</span> <span class="n">padstr</span><span class="p">))</span>
          <span class="k">when</span> <span class="ss">:left</span>
            <span class="n">result</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">padding</span><span class="p">(</span><span class="n">padsize</span><span class="p">,</span> <span class="n">padstr</span><span class="p">))</span>
          <span class="k">when</span> <span class="ss">:center</span>
            <span class="n">lpad</span> <span class="o">=</span> <span class="n">padding</span><span class="p">((</span><span class="n">padsize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">floor</span><span class="p">,</span> <span class="n">padstr</span><span class="p">)</span>
            <span class="n">rpad</span> <span class="o">=</span> <span class="n">padding</span><span class="p">((</span><span class="n">padsize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">.</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ceil</span><span class="p">,</span> <span class="n">padstr</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="vi">@wrapped_string</span><span class="o">.</span><span class="n">dup</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lpad</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rpad</span><span class="p">)</span>
          <span class="k">end</span>
          <span class="n">chars</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">end</span>

        <span class="k">def</span> <span class="nf">padding</span><span class="p">(</span><span class="n">padsize</span><span class="p">,</span> <span class="n">padstr</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
          <span class="k">if</span> <span class="n">padsize</span> <span class="o">!=</span> <span class="mi">0</span>
            <span class="n">chars</span><span class="p">(</span><span class="n">padstr</span> <span class="o">*</span> <span class="p">((</span><span class="n">padsize</span> <span class="o">/</span> <span class="no">Unicode</span><span class="o">.</span><span class="n">u_unpack</span><span class="p">(</span><span class="n">padstr</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padsize</span><span class="p">)</span>
          <span class="k">else</span>
            <span class="s1">&#39;&#39;</span>
          <span class="k">end</span>
        <span class="k">end</span>

        <span class="k">def</span> <span class="nf">chars</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="c1">#:nodoc:</span>
          <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
        <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/mail",depth:3}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../../javascript/docco.min.js"></script>
</html>
